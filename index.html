<!DOCTYPE html>

<head>
    <link rel="shortcut icon" href="#" />
    <meta charset="utf-8" />
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>

    <style>
        @font-face {
            font-family: Gotham;
            src: url('./Fonts/Gotham_Medium_Regular.ttf');
        }

        .page-header {
            text-align: center;
            background-color: #191414;
        }

        .project-name {
            font-size: 3.25rem;
        }

        .project-name {
            color: #1DB954;
            margin-top: 0;
            margin-bottom: 0.1rem;
        }

        .project-tagline {
            color: #fff;
            margin-bottom: 2rem;
            font-weight: normal;
            opacity: 0.7;
            font-size: 1.50rem;
        }

        body {
            /* background-color: #2b2a2a; */
            background-color: #191414;
            font-family: Gotham;
            padding: 0;
            margin: 0;
            font-size: 16px;
            line-height: 1.5;
            /* color: #606c71; */
            color: #1DB954;
            text-align: center;
        }

        .topo {
            color: #606c71;
        }

        .name{
            grid-area: a;
        }
        .name2{
            grid-area: b;
        }
        .graph{
            grid-area: c;
            color: #606c71;
        }
        .graph2{
            grid-area: d;
            color: #606c71;
        }
        .green{
            color: #1DB954;
            margin-left: 15em;
            margin-top: 3em
        }
        .box {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px 2em;
            text-align: center top  ;
        }

        /* div.box2>div {
            text-align: center;
        } */

        .box2 {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 10px 2em;
            text-align: center;
        }

        .tooltip {
            position: absolute;
            opacity: 0.8;
            z-index: 1000;
            text-align: left;
            border-radius: 4px;
            -moz-border-radius: 4px;
            -webkit-border-radius: 4px;
            padding: 8px;
            color: #fff;
            background-color: #000;
            font: 12px sans-serif;
            max-width: 300px;
        }

        table {
            width: 100%;
            font-size: 1.50rem;
        }

        th {
            height: 70px;
        }

        .container {
            margin-top: 30px;
            align-items: start;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-gap: 10px;
            grid-template-areas:
                "a b"
                "c d";
        }

    </style>

    <section class="page-header">
        <h1 class="project-name">Spotify Data Visualisation</h1>
        <h3 class="project-tagline">Bachourian Rafael & Baulard Guillaume & Perreaut Florian</h2>
    </section>

    <section class="Question_1">
        <div>Exploration vs. Chauvinisme (artistes)</div>
        <div class="topo">
            Ici on cherche à faire apparaître un envie constante de nouveau dans les habitudes d'écoute ou à l'inverse
            le fait de revenir toujours vers les mêmes "valeurs sûres".
            A-t-on beaucoup d'artistes avec peu de chansons chacun (large), ou l'inverse (profond) ?
        </div>

        <div class="box">
            <div>Statistiques générales
                <p></p>
                <table>
                    <tr>
                      <th></th>
                      <th>Guillaume</th>
                      <th>Rafael</th>
                    </tr>
                    <tr>
                      <td>Artistes</td>
                      <td>97</td>
                      <td>374</td>
                    </tr>
                    <tr>
                      <td>Albums</td>
                      <td>1195</td>
                      <td>3182</td>
                    </tr>
                    <tr>
                        <td>Chansons</td>
                        <td>7622</td>
                        <td>6583</td>
                    </tr>
                  </table> 
            </div>
            <div id="histo_1">Moyenne du nombre de chansons écoutées par artiste</div>

        <div class="container">
            <div class="name">Statistiques générales</div>
            <div class="name2">Moyenne du nombre de chansons écoutées par artiste</div>
            <div class ="graph green">
                <div class="container">
                    <table>
                        <thead>
                            <tr>
                                <th></th>
                                <th>Total artistes</th>
                                <th>Total albums</th>
                                <th>Total chansons</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Guillaume</td>
                                <td class="topo" id="artistes_G"></td>
                                <td class="topo" id="albums_G"></td>
                                <td class="topo" id="chansons_G"></td>
                            </tr>
                            <tr>
                                <td>Rafael</td>
                                <td class="topo" id="artistes_R"></td>
                                <td class="topo" id="albums_R"></td>
                                <td class="topo" id="chansons_R"></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="graph2" id="histo_1"></div>
>>>>>>> 8002ad389f3ab92f594c76249438dad6ff2b8607
        </div>
    </section>

    <section class="Question_2">
        <div>Eclectisme vs. Chauvinisme (genres musicaux)</div>
        <div class="topo">
            On s'attaque à la présence des genres dans tous les artistes écoutés.
            A-t-on beaucoup de genres qui s'étendent sur tout le spectre musical ou une rotation de seulement quelques
            genres qui monopolisent tous les artistes ?
        </div>
        <div class="container">
            <div class="name">Guillaume</div>
            <div class="name2">Rafael</div>

            <div class="graph" id="pie_chart_1"></div>
            <div class="graph2" id="pie_chart_2"></div>
        </div>

    </section>

    <section class="Question_3">
        <div>Taux de chansons populaires par artiste</div>
        <div class="topo">
            Il s'agit de faire apparaitre la tendance, soit à n'écouter que les titres les plus populaires d'un artiste,
            soit à explorer tout son catalogue.
            Se fie-t-on à l'avis du plus grand nombre ou cherche-t-on à creuser le plus possible par nous-mêmes ?
        </div>
        <div class="topo">
            Pour chaque artiste, on évalue la proportion des chansons écoutées présentes dans le top 10 global de
            l'artiste en nombre d'écoutes.
        </div>
        <div class="box2 container">
            <div class="name">Guillaume</div>
            <div class="name2">Rafael</div>

            <div class="graph" id="curve_1"></div>
            <div class="graph2" id="curve_2"></div>
        </div>

    </section>

    <section class="Graphe_4">
        <div>Popularité des artistes</div>
        <div class="topo">
            Spotify forme un classement global des artistes en leur affectant un indice de popularité entre 0 et 100.
            C'est une combinaisons du nombre de personnes ayant lancé une écoute de l'artiste, du nombre total d'écoutes
            global et de la récence de ces écoutes.
            Nous fions-nous encore une fois à l'avis du plus grand nombre ou cherchons nous à explorer hors des maximums
            locaux ?
        </div>
        <div class="box2 container">
            <div class="name">Guillaume</div>
            <div class="name2">Rafael</div>
            <div class="graph" id="bar4_chart_1"></div>
            <div class="graph2" id="bar4_chart_2"></div>
        </div>
    </section>

    <div>Différences liées au temps d'écoute</div>
    <section class="Graphe_5">
        <div>Taux d'écoute moyen par heure, détaillé</div>
        <div class="topo">
            Il s'agit des variations de temps d'écoute dans la journée.
        </div>
        <div class="box container">
            <div class="name">Guillaume</div>
            <div class="name2">Rafael</div>
            <div class="graph" id="circular_plot_1"></div>
            <div class="graph2" id="circular_plot_2"></div>
        </div>
    </section>

    <section class="Graphe_6">
        <div>Répartition des sessions dans le temps, en intervalles</div>
        <div class="topo">
            Une session est définir par la présence d'écoutes dans des heures consécutives. On montre ici comment les
            sessions se sont étendues dans la journée.
        </div>
        <div class="box container">
            <div class="name">Guillaume</div>
            <div class="name2">Rafael</div>
            <div class="graph" id="arc_diagram_1"></div>
            <div class="graph2" id="arc_diagram_2"></div>
        </div>
    </section>

    <section class="Graphe_7">
        <div>Etude de la présence des artistes dans la chronologie</div>
        <div class="topo">
            On affiche la chronologie totale, en différenciant les artistes, pour faire apparaitre les découvertes
            d'artistes, les vagues d'écoutes, si certains sont tombés dans l'oubli, etc.
        </div>
        <div class="box">
            <div id="stacked_barplot_1"></div>
        </div>
        <div class="box">
            <div id="stacked_barplot_2"></div>
        </div>
    </section>

    <script>

        //lignes Artiste, album, chansons
        data_graph_1 = [[]];
        bar_plot_1 = [["Prenom", "Valeur"]]

        pie_chart_2 = []


        Prenom = "None"
        id = 1

        Promise.all([

            d3.json("/data_final/listing_G.json"),
            d3.json("/data_final/listing_R.json"),
            d3.json("/data_final/chronology_G.json"),
            d3.json("/data_final/chronology_R.json")

        ]).then(function (jsons) {
            var listing_G = jsons[0];
            var listing_R = jsons[1];
            var chronology_G = jsons[2];
            var chronology_R = jsons[3];

            delete chronology_R['2014-12-25'];

            // console.log("Listing_G")
            // console.log(listing_G);
            // console.log("chronology_G")
            // console.log(chronology_G);

            // console.log(listing_R);
            // console.log(chronology_G);
            // console.log(chronology_R);

            // convert ms to hh:mm:ss
            function msToTime(s) {
                // Pad to 2 or 3 digits, default is 2
                var pad = (n, z = 2) => ('00' + n).slice(-z);
                return pad(s / 3.6e6 | 0) + ':' + pad((s % 3.6e6) / 6e4 | 0) + ':' + pad((s % 6e4) / 1000 | 0) + '.' + pad(s % 1000, 3);
            }
            // convert ms to dd:hh:mm
            function dhm(t) {
                Promise
                var cd = 24 * 60 * 60 * 1000,
                    ch = 60 * 60 * 1000,
                    d = Math.floor(t / cd),
                    h = Math.floor((t - d * cd) / ch),
                    m = Math.round((t - d * cd - h * ch) / 60000),
                    pad = function (n) { return n < 10 ? '0' + n : n; };
                if (m === 60) {
                    h++;
                    m = 0;
                }
                if (h === 24) {
                    d++;
                    h = 0;
                }
                return [d, pad(h), pad(m)].join(':');
            }

            // average listening time per hour, day, week, month, year since first day
            // average listen time per hour, detailed
            // session stats
            function average_listens_and_sessions(chronology, since_start_date) {
                var listen_time_per_hour_detailed = [];
                for (let i = 0; i < 24; i++) { listen_time_per_hour_detailed[i] = 0; }
                var session_lengths = [];
                for (let i = 1; i < 18; i++) { session_lengths[i] = 0; }
                var total_sessions = [];
                var total_listen_time = 0;
                Object.keys(chronology).forEach(function (day) {
                    chronology[day]['sessions'].forEach(([start, end]) => {
                        session_lengths[end - start + 1]++;
                        total_sessions.push([start, end]);
                    });
                    Object.keys(chronology[day]).forEach(function (time) {
                        var hour = time.substr(0, 2);
                        var ms_played = chronology[day][time]['ms_played'];
                        if (typeof ms_played !== 'undefined') {
                            total_listen_time += ms_played;
                            listen_time_per_hour_detailed[parseInt(hour)] += ms_played;
                        }
                    });
                });
                for (let i = 0; i < 24; i++) {
                    listen_time_per_hour_detailed[i] *= 1.66667e-5;
                    listen_time_per_hour_detailed[i] /= since_start_date['days_since_start_date'];
                }
                var total_sessions = total_sessions.sort(function (a, b) {
                    if (a[0] == b[0]) return a[1] - b[1];
                    return a[0] - b[0];
                }); pie_chart_1
                var sessions_detailed = {};
                total_sessions.forEach(([start, end]) => {
                    if (sessions_detailed.hasOwnProperty([start, end])) sessions_detailed[[start, end]] += 1;
                    else sessions_detailed[[start, end]] = 1;
                });
                var average_listen_time_per_hour = total_listen_time / since_start_date['hours_since_start_date'];
                var average_listen_time_per_day = total_listen_time / since_start_date['days_since_start_date'];
                var average_listen_time_per_week = total_listen_time / since_start_date['weeks_since_start_date'];
                var average_listen_time_per_month = total_listen_time / since_start_date['months_since_start_date'];
                var average_listen_time_per_year = total_listen_time / since_start_date['years_since_start_date'];

                // // average listening time per hour in the day, in minutes. array of 24 values where the index is the hour in the day
                // console.log("listen time per hour detailed");
                // console.log(listen_time_per_hour_detailed);
                // // average listening time per hour since the beginning in ms
                // console.log("average listen time per hour: " + msToTime(average_listen_time_per_hour));
                // // average listening time per day since the beginning in ms
                // console.log("average listen time per day: " + msToTime(average_listen_time_per_day));
                // // average listening time per hour since the beginning in ms
                // console.log("average listen time per week: " + msToTime(average_listen_time_per_week));
                // // average listening time per hour since the beginning in ms
                // console.log("average listen time per month: " + msToTime(average_listen_time_per_month));
                // // average listening time per hour since the beginning in ms
                // console.log("average listen time per year: " + dhm(average_listen_time_per_year) + " (dd:hh:mm)");
                // // listing of all sessions from the beginning, represented by [start_hour, end_hour]
                // console.log("total sessions");
                // console.log(total_sessions);
                // // object with keys the specific sessions (as in instances of [start, end]) and values the number of times these sessions happened
                // console.log("sessions detailed");
                // console.log(sessions_detailed);
                // // array of values corresponding to the number of sessions of length equal to the index in the array
                // console.log("session lengths");
                // console.log(session_lengths);
                // // total listening time from the beginning
                // console.log("total listen time");
                // console.log(dhm(total_listen_time) + " (dd:hh:mm)");

                csv_listen_time_per_hour_detailed = [["Heures", "Temps"]]

                for (i in listen_time_per_hour_detailed) {
                    csv_listen_time_per_hour_detailed.push([i, listen_time_per_hour_detailed[i]])
                }
                // console.log(csv_listen_time_per_hour_detailed)

                circular_plot_5(csv_listen_time_per_hour_detailed, "circular_plot_" + id, id)

                json_sessions_detailed = { "nodes": [], "links": [] }
                // console.log("CSV_JSON")

                time = 24
                idf = 0
                while (idf < 24) {
                    json_sessions_detailed["nodes"].push({ "id": idf, "name": idf })
                    idf += 1
                }


                for (i in sessions_detailed) {
                    spl = (i + "").split(",")
                    //console.log(spl)
                    json_sessions_detailed["links"].push({ "source": spl[0], "target": spl[1], "value": sessions_detailed[i] })
                }
                //console.log("json_sessions_detailed")
                //console.log(JSON.stringify(json_sessions_detailed))

                arc_diagram_6(1, "arc_diagram_" + id, id)

            }

            // average number of albums listened to per artists, songs per album, songs per artists
            function average_and_total_figures(listing) {
                var total_artists = 0;
                var total_albums = 0;
                var total_songs = 0;
                Object.keys(listing).forEach(function (artist) {
                    total_artists++;
                    Object.keys(listing[artist]).forEach(function (album) {
                        total_albums++;
                        Object.keys(listing[artist][album]).forEach(function (song) {
                            total_songs++;
                        });
                    });
                });
                var average_albums_per_artist = total_albums / total_artists;
                var average_songs_per_artist = total_songs / total_artists;
                var average_songs_per_album = total_songs / total_albums;
                //console.log("total number of artists: " + total_artists);
                //console.log("total number of albums: " + total_albums);
                // console.log("total number of songs: " + total_songs);
                //console.log("average number of albums listened to per artist: " + average_albums_per_artist);
                //console.log("average number of songs listened to per artist: " + average_songs_per_artist);
                //console.log("average number of songs listened to per album: " + average_songs_per_album);

                data_graph_1[id] = [total_artists, total_albums, total_songs]
                console.log(data_graph_1[1])
                bar_plot_1[id] = [Prenom, average_songs_per_artist]

                genres(listing)
                artisteTop(listing)
                artistePop(listing)

            }

            Prenom = "Guillaume"
            since_start_date_G = {};
            since_start_date_G['hours_since_start_date'] = 50327;
            since_start_date_G['days_since_start_date'] = 2096;
            since_start_date_G['weeks_since_start_date'] = 299;
            since_start_date_G['months_since_start_date'] = 69;
            since_start_date_G['years_since_start_date'] = 5.74;
            // console.log("Guillaume");
            average_listens_and_sessions(chronology_G, since_start_date_G);
            average_and_total_figures(listing_G);
            //csvGraphe7(listing_G, chronology_G);
            stacked_barplot_7(1, "stacked_barplot_" + id, id)

            since_start_date_R = {};
            since_start_date_R['hours_since_start_date'] = 55943;
            since_start_date_R['days_since_start_date'] = 2330;
            since_start_date_R['weeks_since_start_date'] = 332;
            since_start_date_R['months_since_start_date'] = 76;
            since_start_date_R['years_since_start_date'] = 6.38;
            Prenom = "Rafael"
            id += 1
            // console.log("Rafael");
            average_listens_and_sessions(chronology_R, since_start_date_R);
            average_and_total_figures(listing_R);
            //csvGraphe7(listing_R,chronology_R)
            stacked_barplot_7(1, "stacked_barplot_" + id, id)

            document.getElementById("artistes_G").textContent = data_graph_1[1][0];
            document.getElementById("albums_G").textContent = data_graph_1[1][1];
            document.getElementById("chansons_G").textContent = data_graph_1[1][2];
            document.getElementById("artistes_R").textContent = data_graph_1[2][0];
            document.getElementById("albums_R").textContent = data_graph_1[2][1];
            document.getElementById("chansons_R").textContent = data_graph_1[2][2];

            //Draw graph
            histogram_1(bar_plot_1)
            //drawPieChart(1,"pie_chart_0")
            //drawPieChart(1,"pie_chart_1")


            //courbe_3(1,"curve_2")

        });

        function artistePop(listing) {

            //console.log("Artiste Pop")

            tabArtistePop = [["artist", "pop"]]
            //Proportion = nb total d'un genre / total des genres par artiste

            Object.keys(listing).forEach(function (artist) {
                //tabArtisteTop[artist] = listing[artist].taux_top_track
                tabArtistePop.push([artist, listing[artist].popularity])
            });

            //console.log(tabArtistePop)

            barchart4(tabArtistePop, "bar4_chart_" + id, id)


        }


        function artisteTop(listing) {

            console.log("Artiste Top")

            tabArtisteTop = [["artist", "top"]]
            //Proportion = nb total d'un genre / total des genres par artiste

            Object.keys(listing).forEach(function (artist) {
                //tabArtisteTop[artist] = listing[artist].taux_top_track
                tabArtisteTop.push([artist, listing[artist].taux_top_track])
            });

            //console.log(tabArtisteTop)

            courbe_3(tabArtisteTop, "curve_" + id, id)

        }


        function genres(listing) {
            console.log("Genres")

            tabGenres = {}
            //Proportion = nb total d'un genre / total des genres par artiste
            total_genres = 0
            Object.keys(listing).forEach(function (artist) {
                total_genres += listing[artist].genres.length
                //console.log(listing[artist].genres)
                for (genre in listing[artist].genres) {
                    if (tabGenres[listing[artist].genres[0]] === undefined) {
                        tabGenres[listing[artist].genres[0]] = 1
                    } else {
                        tabGenres[listing[artist].genres[0]] += 1
                    }
                }
            });

            console.log("total genders " + total_genres)
            console.log(tabGenres)

            drawPieChart(tabGenres, "pie_chart_" + id)

        }


        function csvGraphe7(listing, chronology) {

            console.log("Graphe 7")

            nomArtistes = []
            //Proportion = nb total d'un genre / total des genres par artiste

            Object.keys(listing).forEach(function (artist) {
                //tabArtisteTop[artist] = listing[artist].taux_top_track
                nomArtistes.push(artist)
            });

            nomArtistes.unshift("Mois")

            tabGraphe7 = [nomArtistes]

            zero = new Array(nomArtistes.length - 1).fill(0);

            for (jour in chronology) {
                mois = jour.substr(0, 7);
                exists = false;
                for (ligne in tabGraphe7) {
                    if (tabGraphe7[ligne][0] == mois) {
                        exists = true;
                        break;
                    }
                }
                if (!exists)
                    tabGraphe7.push([mois].concat(zero));
            }
            console.log(tabGraphe7)

            for (jour in chronology) {
                mois = jour.substr(0, 7)
                for (ecoute in chronology[jour]) {
                    //console.log(chronology[jour][ecoute].artist)

                    for (val in tabGraphe7[0]) {
                        //console.log(chronology[jour].artist)
                        if (tabGraphe7[0][val] == chronology[jour][ecoute].artist) {
                            //console.log("Test")
                            for (let j = 1; j < tabGraphe7.length; j++) {
                                if (tabGraphe7[j][0] == mois) {
                                    tabGraphe7[j][val] += 1
                                }
                            }

                        }
                    }

                }
            }
            temp = tabGraphe7.shift();
            tabGraphe7.sort(function cmp(a, b) {
                if (a[0] < b[0])
                    return -1;
                if (a[0] > b[0])
                    return 1;
                return 0;
            })
            tabGraphe7.unshift(temp);
            //console.log("tabGraphe7")
            //console.log(JSON.stringify(tabGraphe7))

            let csvContent = "" +
                tabGraphe7.map(e => e.join(",")).join("\n");

            console.log(csvContent)
        }


        function stacked_barplot_7(data, divname, owner) {

            // set the dimensions and margins of the graph
            const margin = { top: 10, right: 30, bottom: 40, left: 50 },
                width = 1800 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            const svg = d3.select("#" + divname)
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            const div = d3.select("#" + divname).append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);
            // Parse the Data
            d3.csv("./graph_data/data_7_" + owner + ".csv").then(function (data) {

                // List of subgroups = header of the csv files = soil condition here
                const subgroups = data.columns.slice(1)

                // List of groups = species here = value of the first column called group -> I show them on the X axis
                const groups = data.map(d => (d.Mois))

                // Add X axis
                const x = d3.scaleBand()
                    .domain(groups)
                    .range([0, width])
                    .padding([0.2])
                svg.append("g")
                    .attr("transform", `translate(0, ${height})`)
                    .call(d3.axisBottom(x).tickSizeOuter(0))
                    .selectAll("text")
                    .attr("transform", "translate(-20,15)rotate(-45)");

                // Add Y axis
                const y = d3.scaleLinear()
                    .domain([0, 3500])
                    .range([height, 0]);
                svg.append("g")
                    .call(d3.axisLeft(y));

                // color palette = one color per subgroup
                var color = d3.scaleOrdinal().domain(subgroups)
                    .range(d3.schemeSet3);


                //stack the data? --> stack per subgroup
                const stackedData = d3.stack()
                    .keys(subgroups)
                    (data)

                // Show the bars
                svg.append("g")
                    .selectAll("g")
                    // Enter in the stack data = loop key per key = group per group
                    .data(stackedData)
                    .join("g")
                    .attr("fill", d => color(d))
                    .selectAll("rect")
                    // enter a second time = loop subgroup per subgroup to add all rectangles
                    .data(d => d)
                    .join("rect")
                    .attr("x", d => x(d.data.Mois))
                    .attr("y", d => y(d[1]))
                    .attr("height", d => y(d[0]) - y(d[1]))
                    .attr("width", x.bandwidth())
                    .on("mouseover", function (event, d) {
                        div.transition()
                            .duration(200)
                            .style("opacity", .9)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 50) + "px");
                        div.html(d.data)
                    })
                    .on("mouseout", function (event, d) {
                        div.transition()
                            .duration(500)
                            .style("opacity", 0);
                    })
                    ;
            })


        }


        function arc_diagram_6(data, divName, owner) {

            // set the dimensions and margins of the graph
            const margin = { top: 0, right: 30, bottom: 20, left: 30 },
                width = 500 - margin.left - margin.right,
                height = 260 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            const svg = d3.select("#" + divName)
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // Read dummy data

            d3.json("./graph_data/data_6_" + owner + ".json").then(function (data) {

                // List of node names
                var allNodes = data.nodes.map(d => d.name)

                // A linear scale to position the nodes on the X axis
                var x = d3.scalePoint()
                    .range([0, width])
                    .domain(allNodes)

                // Add the circle for the nodes
                svg
                    .selectAll("mynodes")
                    .data(data.nodes)
                    .enter()
                    .append("circle")
                    .attr("cx", d => x(d.name))
                    .attr("cy", height - 30)
                    .attr("r", 8)
                    .style("fill", "#1DB954")

                // And give them a label
                svg
                    .selectAll("mylabels")
                    .data(data.nodes)
                    .enter()
                    .append("text")
                    .attr("x", d => x(d.name))
                    .attr("y", height - 10)
                    .text(d => d.name)
                    .style("text-anchor", "middle")
                    .style("fill", "#606c71")

                // Add links between nodes. Here is the tricky part.
                // In my input data, links are provided between nodes -id-, NOT between node names.
                // So I have to do a link between this id and the name
                var idToNode = {};
                data.nodes.forEach(node =>
                    idToNode[node.id] = node
                );
                // Cool, now if I do idToNode["2"].name I've got the name of the node with id 2

                // Add the links
                svg
                    .selectAll('mylinks')
                    .data(data.links)
                    .enter()
                    .append('path')
                    .attr('d', function (d) {
                        start = x(idToNode[d.source].name)    // X position of start node on the X axis
                        end = x(idToNode[d.target].name)      // X position of end node
                        return ['M', start, height - 30,    // the arc starts at the coordinate x=start, y=height-30 (where the starting node is)
                            'A',                            // This means we're gonna build an elliptical arc
                            (start - end) / 2, ',',    // Next 2 lines are the coordinates of the inflexion point. Height of this point is proportional with start - end distance
                            (start - end) / 2, 0, 0, ',',
                            start < end ? 1 : 0, end, ',', height - 30] // We always want the arc on top. So if end is before start, putting 0 here turn the arc upside down.
                            .join(' ');
                    })
                    .style("fill", "none")
                    .attr("stroke", "#606c71")
            })
        }


        function histogram_1(data) {
            //Bar plot

            let csvContent = "data:text/csv;charset=utf-8," +
                data.map(e => e.join(",")).join("\n");

            //console.log(csvContent)

            // set the dimensions and margins of the graph
            var margin = { top: 30, right: 30, bottom: 70, left: 60 },
                width = 460 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#histo_1")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");
            const div = d3.select("#histo_1").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);
            // Parse the Data
            var dataCsv = d3.csv("./graph_data/data_1.csv");

            dataCsv.then(function (data) {

                // X axis
                var x = d3.scaleBand()
                    .range([0, width])
                    .domain(data.map(d => d.Prenom))
                    .padding(0.2);
                svg.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x))
                    .selectAll("text")
                    .attr("transform", "translate(-10,0)rotate(-45)")
                    .style("text-anchor", "end");

                // Add Y axis
                var y = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.Valeur)])
                    .range([height, 0]);
                svg.append("g")
                    .call(d3.axisLeft(y));

                // Bars
                var bars = svg.selectAll("mybar")
                    .data(data)
                    .enter()
                    .append("rect")
                    .attr("x", function (d) { return x(d.Prenom); })
                    .attr("y", function (d) { return y(d.Valeur); })
                    .attr("width", x.bandwidth())
                    .attr("height", function (d) { return height - y(d.Valeur); })
                    .attr("fill", "#69b3a2")
                    .on("mouseover", function (event, d) {
                        div.transition()
                            .duration(200)
                            .style("opacity", .9)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 50) + "px");
                        div.html(Math.round(d.Valeur))

                    })
                    .on("mouseout", function (event, d) {
                        div.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });
            })

        }

        function circular_plot_5(data, divName, id) {

            let csvContent = "" +
                data.map(e => e.join(",")).join("\n");

            //console.log(csvContent)

            // set the dimensions and margins of the graph
            var margin = { top: 0, right: 0, bottom: 0, left: 0 },
                width = 460 - margin.left - margin.right,
                height = 460 - margin.top - margin.bottom,
                innerRadius = 90,
                outerRadius = Math.min(width, height) / 2;   // the outerRadius goes from the middle of the SVG area to the border

            // append the svg object
            var svg = d3.select("#" + divName)
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + (width / 2 + margin.left) + "," + (height / 2 + margin.top) + ")");

            datacsv = d3.csv("./graph_data/data_5_" + id + ".csv");

            datacsv.then(function (data) {

                // Scales
                var x = d3.scaleBand()
                    .range([0, 2 * Math.PI])    // X axis goes from 0 to 2pi = all around the circle. If I stop at 1Pi, it will be around a half circle
                    .align(0)                  // This does nothing
                    .domain(data.map(function (d) { return d.Heures; })); // The domain of the X axis is the list of states.
                var y = d3.scaleRadial()
                    .range([innerRadius, outerRadius])   // Domain will be define later.
                    .domain([0, 17]); // Domain of Y is from 0 to the max seen in the data

                // Add the bars
                svg.append("g")
                    .selectAll("path")
                    .data(data)
                    .enter()
                    .append("path")
                    .attr("fill", "#69b3a2")
                    .attr("d", d3.arc()     // imagine your doing a part of a donut plot
                        .innerRadius(innerRadius)
                        .outerRadius(function (d) {
                            return y(d['Temps']);
                        })
                        .startAngle(function (d) { return x(d.Heures); })
                        .endAngle(function (d) { return x(d.Heures) + x.bandwidth(); })
                        .padAngle(0.01)
                        .padRadius(innerRadius))

                // Add the labels
                // outer label
                svg.append("g")
                    .selectAll("g")
                    .data(data)
                    .enter()
                    .append("g")
                    .attr("text-anchor", function (d) { return (x(d.Heures) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) < Math.PI ? "end" : "start"; })
                    .attr("transform", function (d) { return "rotate(" + ((x(d.Heures) + x.bandwidth() / 2) * 180 / Math.PI - 90) + ")" + "translate(" + (y(d['Temps']) + 10) + ",0)"; })
                    .append("text")
                    .text(function (d) { return Math.round((parseInt(d['Temps']) + Number.EPSILON) * 100) / 100; })
                    .attr("transform", function (d) { return (x(d.Heures) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) < Math.PI ? "rotate(180)" : "rotate(0)"; })
                    .style("font-size", "11px")
                    .attr("alignment-baseline", "middle")
                    .attr("fill", "#606c71")

                // inner labels
                svg.append("g")
                    .selectAll("g")
                    .data(data)
                    .enter()
                    .append("g")
                    .attr("text-anchor", function (d) { return (x(d.Heures) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) < Math.PI ? "end" : "start"; })
                    .attr("transform", function (d) { return "rotate(" + ((x(d.Heures) + x.bandwidth() / 2) * 180 / Math.PI - 90) + ")" + "translate(" + (y(0) - 5) + ",0)"; })
                    .append("text")
                    .text(function (d) { if (parseInt(d.Heures) % 6 == 0) return (d.Heures); })
                    .attr("transform", function (d) { return (x(d.Heures) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) < Math.PI ? "rotate(0)" : "rotate(180)"; })
                    .style("font-size", "11px")
                    .attr("alignment-baseline", "middle")
                    .attr("fill", "#606c71")

            });

        }

        function barchart4(data, divName, owner) {

            let csvContent = "" +
                data.map(e => e.join(",")).join("\n");

            // set the dimensions and margins of the graph
            var margin = { top: 30, right: 30, bottom: 70, left: 60 },
                width = 4 / Math.log(data.length / 53.0) * data.length - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#" + divName)
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // Parse the Data
            var dataCsv = d3.csv("./graph_data/data_4_" + owner + ".csv");

            dataCsv.then(function (data) {

                // X axis
                var x = d3.scaleBand()
                    .range([0, width])
                    .domain(data.map(d => d.artist))
                    .padding(0.2);
                svg.append("g")
                // .attr("transform", "translate(0," + height + ")")
                // .call(d3.axisBottom(x))
                // .selectAll("text")
                // .attr("transform", "translate(-10,0)rotate(-45)")
                // .style("text-anchor", "end");

                // Add Y axis
                var y = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.pop)])
                    .range([height, 0]);
                svg.append("g")
                    .call(d3.axisLeft(y));

                // Bars
                svg.selectAll("mybar")
                    .data(data)
                    .enter()
                    .append("rect")
                    .attr("x", function (d) { return x(d.artist); })
                    .attr("y", function (d) { return y(d.pop); })
                    .attr("width", x.bandwidth())
                    .attr("height", function (d) { return height - y(d.pop); })
                    .attr("fill", "#69b3a2")
            })


        }


        function courbe_3(data, divName, owner) {

            let csvContent = "" +
                data.map(e => e.join(",")).join("\n");

            // set the dimensions and margins of the graph
            var margin = { top: 30, right: 60, bottom: 70, left: 60 },
                width = 4 / Math.log(data.length / 53.0) * data.length - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;


            // append the svg object to the body of the page
            var svg = d3.select("#" + divName)
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // Parse the Data
            var dataCsv = d3.csv("./graph_data/data_3_" + owner + ".csv");

            dataCsv.then(function (data) {

                // X axis
                var x = d3.scaleBand()
                    .range([0, width])
                    .domain(data.map(d => d.artist))
                    .padding(0.2);
                svg.append("g")
                // .attr("transform", "translate(0," + height + ")")
                // .call(d3.axisBottom(x));
                // .selectAll("text")
                // .attr("transform", "translate(-10,0)rotate(-45)")
                // .style("text-anchor", "end");

                // Add Y axis
                var y = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.top)])
                    .range([height, 0]);
                svg.append("g")
                    .call(d3.axisLeft(y));

                // Bars
                svg.selectAll("mybar")
                    .data(data)
                    .enter()
                    .append("rect")
                    .attr("x", function (d) { return x(d.artist); })
                    .attr("y", function (d) { return y(d.top); })
                    .attr("width", x.bandwidth())
                    .attr("height", function (d) { return height - y(d.top); })
                    .attr("fill", "#69b3a2")
            })

        }


        function drawPieChart(data, divName) {
            tot = 0
            for (d in data) {
                tot += data[d]
            }

            ndata = {}
            ndata["other"] = 0
            for (d in data) {
                //On garde seulement les genres qui sont > à 1/25 du total
                //Les reste est dans la catégorie "other"
                if (data[d] < tot / 50) {
                    ndata["other"] = data[d] + ndata["other"]
                } else {
                    ndata[d] = data[d]
                }
            }

            var genres = Object.keys(ndata);

            var data = Object.values(ndata)

            var data = Object.values(data)

            var margin = { top: 30, right: 30, bottom: 70, left: 60 },
                width = 460 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#" + divName)
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)


            // Creating Pie generator
            var pie = d3.pie();

            // Creating arc
            var arc = d3.arc()
                .innerRadius(0)
                .outerRadius(100);

            let g = svg.append("g")
                .attr("transform", "translate(150,120)");

            // Grouping different arcs
            var arcs = g.selectAll("arc")
                .data(pie(data))
                .enter()
                .append("g");

            // Appending path
            arcs.append("path")
                .attr("fill", (data, i) => {
                    let value = data.data;
                    return d3.schemeSet3[i + 1];
                })
                .attr("d", arc);

            // Adding data to each arc
            arcs.append("text")
                .attr("transform", (d) => {
                    radius = 130;
                    return "translate(" +
                        ((radius - 12) * Math.sin(((d.endAngle - d.startAngle) / 2) + d.startAngle)) +
                        ", " +
                        (-1 * (radius - 12) * Math.cos(((d.endAngle - d.startAngle) / 2) + d.startAngle)) +
                        ")";
                })
                .style("text-anchor", function (d) {
                    var rads = ((d.endAngle - d.startAngle) / 2) + d.startAngle;
                    if ((rads > 7 * Math.PI / 4 && rads < Math.PI / 4) || (rads > 3 * Math.PI / 4 && rads < 5 * Math.PI / 4)) {
                        return "middle";
                    } else if (rads >= Math.PI / 4 && rads <= 3 * Math.PI / 4) {
                        return "start";
                    } else if (rads >= 5 * Math.PI / 4 && rads <= 7 * Math.PI / 4) {
                        return "end";
                    } else {
                        return "middle";
                    }
                })
                //.data(pie(genres)) //ajout nom genre
                .text(function (d, i) {
                    if (d.endAngle - d.startAngle > 0.3)
                        return genres[i];
                })                
                .style("fill", "#606c71")

        }


    </script>
</body>